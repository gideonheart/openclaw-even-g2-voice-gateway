---
phase: 02-configuration-and-hardening
plan: 02
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - services/gateway-api/src/server.ts
  - services/gateway-api/src/index.ts
autonomous: true
requirements:
  - CONF-01
  - CONF-02
  - CONF-05
  - OPS-02
  - OPS-03
  - SAFE-05
  - SAFE-06
  - SAFE-07

must_haves:
  truths:
    - "POST /api/settings accepts a JSON body, validates it via validateSettingsPatch, updates the ConfigStore, and returns the safe config (secrets masked)"
    - "GET /api/settings reads from ConfigStore.getSafe() instead of static config"
    - "CORS rejects non-allowlisted origins with 403 when corsOrigins is configured"
    - "CORS allows all origins when corsOrigins is empty (development mode)"
    - "Gateway refuses all traffic with 503 NOT_READY until startup pre-checks pass"
    - "Startup pre-checks validate STT provider and OpenClaw connectivity before accepting traffic"
    - "Settings endpoint has 64KB body size limit and is rate-limited"
    - "Secrets never appear in POST /api/settings response, only SafeGatewayConfig"
    - "GET /readyz reads the active provider from ConfigStore (not static config)"
  artifacts:
    - path: "services/gateway-api/src/server.ts"
      provides: "Updated HTTP server with ConfigStore wiring, POST settings handler, strict CORS, readiness flag"
      exports: ["createGatewayServer", "ServerDeps"]
    - path: "services/gateway-api/src/index.ts"
      provides: "Startup readiness gate, ConfigStore creation, provider re-initialization on settings change"
      contains: "ConfigStore"
  key_links:
    - from: "services/gateway-api/src/server.ts"
      to: "services/gateway-api/src/config-store.ts"
      via: "imports ConfigStore, validateSettingsPatch, ValidatedSettingsPatch"
      pattern: "import.*ConfigStore.*config-store"
    - from: "services/gateway-api/src/server.ts"
      to: "@voice-gateway/shared-types"
      via: "uses ErrorCodes.CORS_REJECTED and ErrorCodes.NOT_READY"
      pattern: "ErrorCodes\\.CORS_REJECTED|ErrorCodes\\.NOT_READY"
    - from: "services/gateway-api/src/index.ts"
      to: "services/gateway-api/src/config-store.ts"
      via: "creates ConfigStore instance, passes to createGatewayServer"
      pattern: "new ConfigStore"
    - from: "services/gateway-api/src/server.ts"
      to: "services/gateway-api/src/server.ts"
      via: "handlePostSettings calls validateSettingsPatch then configStore.update then configStore.getSafe"
      pattern: "validateSettingsPatch.*configStore\\.update.*configStore\\.getSafe"
---

<objective>
Wire the ConfigStore into the HTTP server and entry point, implement the POST /api/settings handler, harden CORS to reject non-allowlisted origins, add the startup readiness gate, and ensure secrets never leak.

Purpose: This plan transforms the gateway from a static-config server into a runtime-configurable, production-hardened service. After this, the chat app can POST settings and GET them back with secrets masked, the gateway rejects unauthorized origins, and the server refuses traffic until dependencies are verified healthy.

Output: Updated server.ts with ConfigStore integration, POST settings handler, strict CORS, readiness flag. Updated index.ts with ConfigStore creation, startup pre-checks, and provider re-initialization on config change.
</objective>

<execution_context>
@/home/forge/.claude/get-shit-done/workflows/execute-plan.md
@/home/forge/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-configuration-and-hardening/02-RESEARCH.md
@.planning/phases/02-configuration-and-hardening/02-01-SUMMARY.md

@services/gateway-api/src/server.ts
@services/gateway-api/src/index.ts
@services/gateway-api/src/config-store.ts
@services/gateway-api/src/orchestrator.ts
@packages/shared-types/src/config.ts
@packages/shared-types/src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire ConfigStore into server, implement POST settings, harden CORS</name>
  <files>services/gateway-api/src/server.ts</files>
  <action>
    **1. Update ServerDeps to use ConfigStore:**

    Change `ServerDeps` interface:
    ```typescript
    export interface ServerDeps {
      readonly configStore: ConfigStore;  // was: readonly config: GatewayConfig
      readonly sttProviders: Map<string, SttProvider>;
      readonly openclawClient: OpenClawClient;
      readonly logger: Logger;
      ready: boolean;  // mutable readiness flag for startup gate
    }
    ```

    Import `ConfigStore` and `validateSettingsPatch` from `./config-store.js`.

    **2. Add readiness gate at the top of the request handler:**

    Before routing, check `deps.ready`. If false and URL is not `/healthz`, return 503 with `{ error: "Gateway is starting up", code: ErrorCodes.NOT_READY }`. The `/healthz` endpoint must always be accessible (liveness probe).

    **3. Update all config reads to go through ConfigStore:**

    Replace every `deps.config` reference with `deps.configStore.get()`:
    - `deps.config.server.corsOrigins` → `deps.configStore.get().server.corsOrigins`
    - `deps.config.server.maxAudioBytes` → `deps.configStore.get().server.maxAudioBytes`
    - `deps.config.openclawSessionKey` → `deps.configStore.get().openclawSessionKey`
    - `deps.config.sttProvider` → `deps.configStore.get().sttProvider`
    - RateLimiter constructor: `deps.configStore.get().server.rateLimitPerMinute`

    **4. Implement handlePostSettings:**

    ```typescript
    async function handlePostSettings(
      req: IncomingMessage,
      res: ServerResponse,
      deps: ServerDeps,
      log: Logger,
    ): Promise<void> {
      // SAFE-06: Body size limit for settings (64KB max — settings are small JSON)
      const body = await readBody(req, 64 * 1024);

      let parsed: unknown;
      try {
        parsed = JSON.parse(body.toString("utf-8"));
      } catch {
        throw new UserError(ErrorCodes.INVALID_CONFIG, "Request body is not valid JSON");
      }

      const patch = validateSettingsPatch(parsed);
      deps.configStore.update(patch);

      log.info("Settings updated successfully");

      // CONF-05: Return safe config, never raw
      sendJson(res, 200, deps.configStore.getSafe());
    }
    ```

    Update the route to pass `deps` to handlePostSettings (currently only passes `req, res, log`).

    **5. Update handleGetSettings to read from ConfigStore:**

    Change signature to accept `configStore: ConfigStore` instead of `config: GatewayConfig`. Call `configStore.getSafe()` directly instead of manually building SafeGatewayConfig. This eliminates the duplicated masking logic (now lives in ConfigStore).

    **6. Harden CORS — strict rejection (SAFE-07):**

    Update `handleCors` function:
    - If `allowedOrigins.length > 0` and request has an `Origin` header that is NOT in the allowlist: return 403 with `{ error: "Origin not allowed", code: ErrorCodes.CORS_REJECTED }`. Set `return true` to stop further processing.
    - If `allowedOrigins.length === 0`: allow all origins (development mode — no CORS enforcement).
    - If origin matches allowlist: add CORS headers as before.
    - Preflight (OPTIONS) for non-matching origins when allowlist is configured: return 204 without CORS headers (browser will block the actual request).

    Import `ErrorCodes` CORS_REJECTED (added in Plan 01).

    **7. Rate-limit the settings endpoint (SAFE-06):**

    Apply the existing `rateLimiter.check(clientIp)` to the `POST /api/settings` route, same as voice turn. Use the same rate limiter instance.

    **8. Update handleReadyz to read from ConfigStore (OPS-02):**

    Change `deps.config.sttProvider` → `deps.configStore.get().sttProvider` so readyz always checks the currently-active provider after runtime config changes.

    **9. Secret masking audit (SAFE-05):**

    Verify that `handlePostSettings` returns `configStore.getSafe()` (not raw config). Verify that the `requestLog` in the request handler does not log the settings body or any secret fields. The existing `Logger.maskSecrets` handles structured log output, but ensure we never pass raw settings payload to the logger. Log only `"Settings updated successfully"` without the payload.
  </action>
  <verify>
    <automated>cd /home/forge/openclaw-even-g2-voice-gateway && npx tsc --noEmit</automated>
    <manual>Review server.ts to confirm: (1) all deps.config replaced with deps.configStore.get(), (2) handleCors rejects with 403, (3) handlePostSettings uses readBody with 64KB limit, (4) readiness gate returns 503, (5) no secrets in log statements.</manual>
  </verify>
  <done>ServerDeps uses ConfigStore. POST /api/settings validates, updates, and returns safe config. CORS rejects non-allowlisted origins with 403. Settings endpoint has 64KB body limit and is rate-limited. Readiness gate returns 503 when not ready. GET /readyz reads from ConfigStore. No secrets in log output.</done>
</task>

<task type="auto">
  <name>Task 2: Wire ConfigStore in entry point, add startup gate, provider re-initialization</name>
  <files>services/gateway-api/src/index.ts</files>
  <action>
    **1. Create ConfigStore in main():**

    ```typescript
    import { ConfigStore } from "./config-store.js";

    const config = loadConfig();
    const configStore = new ConfigStore(config);
    ```

    **2. Initialize STT providers (unchanged, but store reference for re-init):**

    Keep the existing provider initialization logic. Store provider construction in a helper function so it can be called again on config change:

    ```typescript
    function buildSttProviders(cfg: GatewayConfig): Map<string, SttProvider> {
      const providers = new Map<string, SttProvider>();
      providers.set(ProviderIds.WhisperX, new WhisperXProvider(cfg.whisperx, rootLogger));
      providers.set(ProviderIds.OpenAI, new OpenAIProvider(cfg.openai, rootLogger));
      providers.set(ProviderIds.Custom, new CustomHttpProvider(cfg.customHttp, rootLogger));
      return providers;
    }

    let sttProviders = buildSttProviders(config);
    ```

    **3. Add startup pre-check (OPS-03):**

    Before starting the server:
    ```typescript
    log.info("Running startup pre-checks");
    const activeProvider = sttProviders.get(config.sttProvider);
    const [sttHealth, clawHealth] = await Promise.all([
      activeProvider?.healthCheck() ??
        Promise.resolve({ healthy: false, message: "No active provider configured", latencyMs: 0 }),
      openclawClient.healthCheck(),
    ]);

    if (!sttHealth.healthy || !clawHealth.healthy) {
      log.error("Startup pre-check failed", { stt: sttHealth, openclaw: clawHealth });
      process.exit(1);
    }
    log.info("Startup pre-checks passed", { stt: sttHealth, openclaw: clawHealth });
    ```

    Add an overall startup timeout (30 seconds) using `setTimeout` that calls `process.exit(1)` if pre-checks hang:
    ```typescript
    const startupTimeout = setTimeout(() => {
      log.error("Startup timed out after 30s");
      process.exit(1);
    }, 30_000);
    // ... run pre-checks ...
    clearTimeout(startupTimeout);
    ```

    **4. Create server with ConfigStore and readiness flag:**

    ```typescript
    const deps: ServerDeps = {
      configStore,
      sttProviders,
      openclawClient,
      logger: rootLogger,
      ready: false,
    };

    const server = createGatewayServer(deps);
    ```

    After startup pre-checks pass, set `deps.ready = true`.

    **5. Start listening (unchanged except for ConfigStore reads):**

    ```typescript
    const serverConfig = configStore.get().server;
    server.listen(serverConfig.port, serverConfig.host, () => {
      deps.ready = true;
      log.info("Gateway API started", {
        port: serverConfig.port,
        host: serverConfig.host,
        sttProvider: configStore.get().sttProvider,
      });
    });
    ```

    Set `deps.ready = true` inside the listen callback (after port is bound), not before.

    **6. Graceful shutdown (unchanged but read from configStore):**

    Keep existing shutdown logic. No changes needed since the server reference is already captured.

    **7. Note on provider re-initialization:**

    For Phase 2, the simplest approach per research: when POST /api/settings changes provider-specific config, the orchestrator reads `configStore.get().sttProvider` per-request to select the active provider. However, provider instances were constructed with old config values. Document this limitation with a TODO comment:

    ```typescript
    // TODO(phase-3): When provider-specific config changes (e.g., whisperx.baseUrl),
    // reconstruct the affected provider instance. For Phase 2, provider selection
    // (which provider is active) works immediately because the orchestrator reads
    // config per-request, but provider-specific settings (URLs, models) require restart.
    ```

    This is acceptable because Phase 3 (Provider Extensibility) will properly handle runtime provider switching with instance reconstruction.
  </action>
  <verify>
    <automated>cd /home/forge/openclaw-even-g2-voice-gateway && npx tsc --noEmit</automated>
    <manual>Review index.ts to confirm: (1) ConfigStore is created and passed to createGatewayServer, (2) startup pre-checks run before server.listen, (3) ready flag is set after listen callback, (4) startup timeout prevents hanging.</manual>
  </verify>
  <done>index.ts creates ConfigStore from loadConfig(), runs startup pre-checks with 30s timeout, creates server with deps.ready=false, sets ready=true in listen callback. TypeScript compiles with no errors. Provider re-init deferred to Phase 3 with documented TODO.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — full workspace type-check passes with no errors
2. `npx vitest run` — all existing tests still pass (no regressions from ServerDeps refactor)
3. Manual review: `server.ts` has zero references to `deps.config` (all replaced with `deps.configStore.get()`)
4. Manual review: `handleCors` returns 403 for non-allowlisted origins when corsOrigins is non-empty
5. Manual review: `handlePostSettings` calls `readBody(req, 64 * 1024)`, `validateSettingsPatch`, `configStore.update`, returns `configStore.getSafe()`
6. Manual review: `index.ts` runs pre-checks before `server.listen()`, has 30s startup timeout
7. Manual review: No raw config or secrets logged anywhere in new code
</verification>

<success_criteria>
- POST /api/settings accepts valid JSON, validates, updates ConfigStore, returns safe config with masked secrets
- GET /api/settings returns ConfigStore.getSafe() (not manually built masking)
- CORS rejects non-allowlisted origins with 403 CORS_REJECTED
- Settings endpoint has 64KB body limit and is rate-limited
- Gateway returns 503 NOT_READY before startup pre-checks pass
- Startup pre-checks validate STT and OpenClaw health with 30s timeout
- GET /readyz reads active provider from ConfigStore
- All existing tests pass (no regressions)
- TypeScript strict mode compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-configuration-and-hardening/02-02-SUMMARY.md`
</output>
